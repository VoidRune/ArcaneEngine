#version 450
#include "common.glsl"
#include "random.glsl"

layout(set = 0, binding = 0) uniform GlobalFrameData{
    mat4 projection;
    mat4 view;
    mat4 inverseProjection;
    mat4 inverseView;
    vec4 cameraPosition;
    vec4 cameraDirection;
    uint frameIndex;
    int bounceLimit;
    float extinction;
    float anisotropy;
    vec3 backgroundColor;
} globalData;

layout(set = 1, binding = 0, rgba32f) uniform image2D accumulationImageIn;
layout(set = 1, binding = 1, rgba32f) uniform image2D accumulationImageOut;
layout(set = 1, binding = 2, rgba8) uniform image2D outputImage;
layout(set = 1, binding = 3) uniform sampler3D datasetImage;
layout(set = 1, binding = 4) uniform sampler2D transferFunctionImage;
layout(set = 1, binding = 5) uniform sampler3D extinctionGrid;
layout(set = 1, binding = 6, r8) uniform image3D outputExtinctionGrid;
layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;


struct Photon {
    vec3 position;
    vec3 direction;
    vec3 transmittance;
    vec3 radiance;
    uint bounces;
};


float FetchAndUpdateExtinction(vec3 samplePoint, float gridSize) {
    float currentExtinction = texture(extinctionGrid, samplePoint).r;
    float localDensity = texture(transferFunctionImage, vec2(texture(datasetImage, samplePoint).r, 0.5)).a;
    float updatedExtinction = max(currentExtinction, localDensity + 1e-4f);
    if (updatedExtinction > currentExtinction) {
        ivec3 superVoxel = ivec3(samplePoint * gridSize);
        imageStore(outputExtinctionGrid, superVoxel, vec4(updatedExtinction));
    }
    return updatedExtinction;
}

bool PerformVoxelTraversal(inout Photon p, inout uint rng, out float extinction)
{
    int gridSize = textureSize(extinctionGrid, 0).r;

    vec3 invDir = 1 / p.direction;
    vec3 rayGradient = abs(invDir / gridSize);

    ivec3 cellIndex =  ivec3(p.position * gridSize);
    vec3 lengthStepped = (p.position * gridSize - vec3(cellIndex)) * rayGradient;
    
    if(p.direction.x > 0) lengthStepped.x = (cellIndex.x + 1.0f - p.position.x * gridSize) * rayGradient.x;
    if(p.direction.y > 0) lengthStepped.y = (cellIndex.y + 1.0f - p.position.y * gridSize) * rayGradient.y;
    if(p.direction.z > 0) lengthStepped.z = (cellIndex.z + 1.0f - p.position.z * gridSize) * rayGradient.z;

    float freePath = -log(RandomValue(rng)) / globalData.extinction;
    float umin = 0.0f;
    float umax = 0.0f;

    while(true)
    {
        umin = umax;
        if (lengthStepped.x < lengthStepped.y && lengthStepped.x < lengthStepped.z) {
            umax = lengthStepped.x; 
            lengthStepped.x += rayGradient.x;
        } else if (lengthStepped.y < lengthStepped.x && lengthStepped.y < lengthStepped.z) {
            umax = lengthStepped.y; 
            lengthStepped.y += rayGradient.y;
        } else {
            umax = lengthStepped.z; 
            lengthStepped.z += rayGradient.z;  
        }

        vec3 midpoint = p.position + p.direction * (umin + umax) * 0.5;
        if (any(greaterThan(midpoint, vec3(1 + 1e-4))) || any(lessThan(midpoint, vec3(0 - 1e-4)))) {
            return false;
        }

        vec3 samplePoint = clamp(vec3(midpoint.x, 1.0 - midpoint.y, midpoint.z), vec3(0.0f), vec3(1.0f));
        extinction = FetchAndUpdateExtinction(samplePoint, gridSize);

        float d = umax - umin;
        float opticalThickness = extinction * d;
        
        if (opticalThickness >= freePath)
        {
            float t = freePath / extinction;
            p.position = p.position + p.direction * (umin + t);
            return true;
        }
        freePath -= opticalThickness;
    }
}


void main() 
{
    ivec2 px = ivec2(gl_GlobalInvocationID.xy);
	vec2 size = imageSize(outputImage);
    uint rng = globalData.frameIndex;

    // added tiny blur effect for antialiasing
    float blurAmount = 1.0f;
    vec2 blur = vec2(RandomValue(rng) * blurAmount, RandomValue(rng) * blurAmount) * 2.0 - 1.0;
    vec2 uv = (px + blur) / size;

    vec3 rayOrigin = globalData.cameraPosition.xyz;
    vec4 rayTarget = globalData.inverseProjection * vec4(uv * 2.0 - 1.0, 1.0, 1.0);
    vec3 rayDirection = vec3(globalData.inverseView * vec4(normalize(rayTarget.xyz / rayTarget.w), 0.0));

    float tmin;
    float tmax;
    bool intersect = RayBox(rayOrigin, rayDirection, vec3(0.0f), vec3(1.0f), tmin, tmax);
    tmin = max(tmin, 0.0);
    float maxDist = tmax - tmin;

    vec4 outputColor = vec4(globalData.backgroundColor, 1);
    vec3 pos = rayOrigin + rayDirection * tmin;

    if(intersect)
    {
        outputColor = vec4(0, 0, 0, 1);
        //int maxSteps = 20;
        //for (float i = 0; i < maxSteps; i++)
        //{
        //    float ratio = (i + RandomValue(rng)) / maxSteps;
        //    vec3 point = (pos + rayDirection * maxDist * ratio);
        //    point.y = 1.0 - point.y;
        //    float r = texture(extinctionGrid, point).r * 10.0f;
        //    outputColor.r += r / maxSteps;
        //}

        
        Photon photon;
        photon.position = rayOrigin + rayDirection * tmin;
        photon.direction = rayDirection;
        photon.bounces = 0;
        photon.transmittance = vec3(1.0f);
        photon.radiance = vec3(0);

        uint rng = globalData.frameIndex;
        for (int limit = 0; limit < 1000; limit++)
        {
            float extinction = 0.0f;
            if(!PerformVoxelTraversal(photon, rng, extinction))
            {
                vec3 envSample = globalData.backgroundColor;
                vec3 radiance = photon.transmittance * envSample.rgb;
                photon.radiance += (radiance - photon.radiance);
                break;
            }

            //float step = -log(RandomValue(rng)) / globalData.extinction;
            //photon.position += step * photon.direction;
            //if (any(greaterThan(photon.position, vec3(1))) || any(lessThan(photon.position, vec3(0)))) {
            //    // out of bounds
            //    vec3 envSample = globalData.backgroundColor;
            //    vec3 radiance = photon.transmittance * envSample.rgb;
            //    photon.radiance += (radiance - photon.radiance);                
            //    break;
            //}

            vec3 samplePoint = photon.position;
            samplePoint.y = 1 - samplePoint.y;
            float datasetIndex = texture(datasetImage, samplePoint).r;
            //float maxExtinction = texture(maxExtinctionImage, samplePoint).r;
            vec4 transferFunction = texture(transferFunctionImage, vec2(datasetIndex, 0.5));



            //extinction = 1;
            float absorption = 0.1f;
            float scattering = 0.9f;

            float real = min(extinction, transferFunction.a);
            float PNull = (extinction - real) / extinction;
            float PAbsorption = (real * absorption) / extinction;
            float PScattering = (real * scattering) / extinction;

            
            //float PScattering;
            //float PNull = 1.0f - transferFunction.a;
            //if (photon.bounces >= globalData.bounceLimit) {
            //    PScattering = 0.0;
            //} else {
            //    PScattering = transferFunction.a * max3(transferFunction.rgb);
            //}
            //float PAbsorption = 1.0 - PNull - PScattering;

            float rand = RandomValue(rng);
            if (rand < PAbsorption) {
                // absorption
                vec3 radiance = vec3(0);
                photon.radiance += (radiance - photon.radiance);
                break;
            } else if (rand < PAbsorption + PScattering) {
                // scattering
                photon.transmittance *= photon.transmittance * transferFunction.rgb;
                photon.direction = sampleHenyeyGreenstein(rng, globalData.anisotropy, photon.direction);
                photon.bounces++;
            } else {
                // null collision
            }
        }

        outputColor.rgb += photon.radiance;
    }

    if(globalData.frameIndex > 1)
        outputColor += imageLoad(accumulationImageIn, px);
    imageStore(accumulationImageOut, px, outputColor);
    imageStore(outputImage, px, outputColor / globalData.frameIndex);
}