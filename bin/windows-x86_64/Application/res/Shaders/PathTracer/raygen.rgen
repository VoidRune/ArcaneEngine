#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_shader_image_load_formatted : enable
#include "common.glsl"

layout(set = 1, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 1, binding = 1, rgba32f) uniform image2D accumulationImageIn;
layout(set = 1, binding = 2, rgba32f) uniform image2D accumulationImageOut;
layout(set = 1, binding = 3, rgba8) uniform image2D outputImage;
layout(set = 1, binding = 4) uniform GlobalData 
{
	mat4 viewInverse;
	mat4 projInverse;
	uint frameIndex;
} globalData;

layout(location = 0) rayPayloadEXT RayPayload payload;

struct Photon
{
    vec3 pos;
    vec3 dir;
    vec3 light;
};

void main()
{
	
	ivec2 px = ivec2(gl_LaunchIDEXT.xy);
	vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);

	uint rng = globalData.frameIndex;
    rng = rng * (px.x + 73) * (px.y + 91);
	// added tiny blur effect for anti-aliasing
    float blurAmount = 0.5f;
    vec2 blur = RandomCircle(rng) * blurAmount;
	vec2 uv = (pixelCenter + blur) / vec2(gl_LaunchSizeEXT.xy);
	vec2 d = uv * 2.0 - 1.0;

	vec4 origin = globalData.viewInverse * vec4(0,0,0,1);
	vec4 target = globalData.projInverse * vec4(d.x, d.y, 1, 1);
	vec4 direction = globalData.viewInverse*vec4(normalize(target.xyz), 0);

	
	float tmin = 0.001;
	float tmax = 10000.0;

	vec3 radiance = vec3(0);
	int raysPerDispatch = 4;
	int bounceLimit = 16;
	for (int j = 0; j < raysPerDispatch; j++)
	{
		Photon photon;
		photon.pos = origin.xyz;
		photon.dir = direction.xyz;
		photon.light = vec3(1);

		for (int i = 0; i < bounceLimit; i++)
		{
			traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, photon.pos, tmin, photon.dir, tmax, 0);
			if (payload.hitInfo == 0)
			{
				vec3 emittedLight = payload.color;
				radiance += emittedLight * photon.light;
				break;
			}

			//float mu = 0.2;
			//float freePath = -log(RandomValue(rng)) / mu;
			//if (freePath < payload.hitDistance)
			//{
			//	photon.pos = photon.pos + normalize(photon.dir) * freePath;
			//	//photon.dir = sampleHenyeyGreenstein(rng, 0.4, photon.dir);
			//	photon.dir = RandomSphere(rng);
			//	//photon.light *= vec3(0.95, 0.8, 0.8);
			//}
			//else
			{
				photon.pos = payload.origin;
				photon.dir = payload.normal + RandomSphere(rng);
				photon.light *= payload.color;
			}
			//photon.dir = reflect(photon.dir, payload.normal);
		}
	}
	radiance /= raysPerDispatch;

	if(globalData.frameIndex > 1)
        radiance += imageLoad(accumulationImageIn, px).rgb;
    imageStore(accumulationImageOut, px, vec4(radiance, 0));
	imageStore(outputImage, px, vec4(radiance / globalData.frameIndex, 0));
}