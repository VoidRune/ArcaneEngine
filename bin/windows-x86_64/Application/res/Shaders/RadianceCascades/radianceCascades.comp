#version 450

layout(set = 0, binding = 0) uniform sampler2D sdfImage;
layout(set = 0, binding = 1) uniform sampler2D nearestColor;
layout(set = 0, binding = 2, rgba8) uniform image2D currentCascade;
layout(set = 0, binding = 3) uniform sampler2D upperCascade;

layout( push_constant ) uniform constants
{
	float cascadeIndex;
	float cascadeInterval;
	float cascadeCount;
} pushConstants;

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

struct ProbeInfo
{
	vec2 position;
	float offset;
	float range;
	float theta;
};

vec4 raymarch(ProbeInfo probe, vec2 canvasSize)
{
    vec2 rayDir = vec2(cos(probe.theta), -sin(probe.theta));
    vec2 rayOrigin = probe.position + rayDir * probe.offset;

    float totalDistance = 0.0;
    for (int i = 0; i < 64 && totalDistance < probe.range; i++)
    {
        vec2 uv = (rayOrigin + rayDir * totalDistance) / canvasSize;
		if (any(lessThan(uv, vec2(0.0))) || any(greaterThan(uv, vec2(1.0))))
            return vec4(0);
        vec2 dd = abs(rayDir);
        float dist = texture(sdfImage, uv).r;
        if (dist <= 1.0f)
            return vec4(texture(nearestColor, uv).rgb, 1);

        totalDistance += dist;
    }
    return vec4(0);
}

vec4 merge(vec4 radiance, int rayIndex, vec2 uv)
{
	if (radiance.a == 1 || pushConstants.cascadeIndex >= pushConstants.cascadeCount - 1)
		return radiance;

	int angularUpper = 1 << int(pushConstants.cascadeIndex + 1);
	ivec2 groupIndex = ivec2(rayIndex % angularUpper, rayIndex / angularUpper);
	return radiance + texture(upperCascade, (uv + vec2(groupIndex)) / float(angularUpper));
}

void main()
{
    ivec2 px = ivec2(gl_GlobalInvocationID.xy);
	ivec2 cascadeExtent = imageSize(currentCascade);
	vec2 canvasSize = textureSize(sdfImage, 0);

	int angularSqrt = 1 << int(pushConstants.cascadeIndex);
	ivec2 linearDist = cascadeExtent / angularSqrt;
	
	ivec2 probeIndex = px % linearDist;
	ivec2 groupIndex = px / linearDist;

	int rayIndex = groupIndex.y * angularSqrt + groupIndex.x;
	int angular = angularSqrt * angularSqrt;

	ProbeInfo probe;
	probe.position = (probeIndex + 0.5) * angularSqrt * (canvasSize / vec2(cascadeExtent));
	probe.offset = (pushConstants.cascadeInterval * (angular - 1)) / 3.0;
	probe.range = pushConstants.cascadeInterval * angular;

	const float TAU = 6.2831853;
	float invAngular = 1.0 / float(angular * 4);
	int preavgIndex = rayIndex * 4;
	vec2 uvClamp = 2.0 * angularSqrt / canvasSize;
	vec2 radianceGroupUv = clamp(probe.position / canvasSize, uvClamp, vec2(1) - uvClamp);

    vec4 radiance = vec4(0);
	for (int i = 0; i < 4; i++)
	{
		int index = preavgIndex + i;
		probe.theta = float(index + 0.5) * invAngular * TAU;

		radiance += merge(raymarch(probe, canvasSize), index, radianceGroupUv) * 0.25;
	}
	imageStore(currentCascade, px, radiance);
}