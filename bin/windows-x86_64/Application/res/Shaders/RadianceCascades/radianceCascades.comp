#version 450

layout(set = 0, binding = 0) uniform sampler2D sdfImage;
layout(set = 0, binding = 1, rgba8) uniform image2D currentCascade;
layout(set = 0, binding = 2) uniform sampler2D upperCascade;

layout( push_constant ) uniform constants
{
	float cascadeIndex;
	float cascadeInterval;
	float cascadeCount;
} pushConstants;

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

struct ProbeInfo
{
	vec2 position;
	float offset;
	float range;
	float theta;
};

vec4 raymarch(ProbeInfo probe, vec2 extent)
{
    vec2 rayDir = vec2(cos(probe.theta), -sin(probe.theta));
    vec2 rayOrigin = probe.position + rayDir * probe.offset;

    float totalDistance = 0.0;
    for (int i = 0; i < 16 && totalDistance < probe.range; i++)
    {
        vec2 uv = (rayOrigin + rayDir * totalDistance) / extent;
        if (uv.x < 0 || uv.x > 1 || uv.y < 0 || uv.y > 1)
            return vec4(0);
        vec2 dd = abs(rayDir);
        vec4 nearest = texture(sdfImage, uv);
        float dist = nearest.a * dot(dd, extent) / (dd.x + dd.y);
        if (dist <= 0.05f)
            return vec4(nearest.rgb, 1);

        totalDistance += dist;
    }
    return vec4(0);
}

vec4 merge(vec4 radiance, int rayIndex, vec2 uv)
{
	if (radiance.a >= 1 || pushConstants.cascadeIndex >= pushConstants.cascadeCount - 1)
		return radiance;

	float angularUpper = pow(2, pushConstants.cascadeIndex + 1);
	float x = rayIndex % int(angularUpper);
	float y = floor(rayIndex / angularUpper);
	return radiance + texture(upperCascade, (uv + vec2(x, y)) / angularUpper);
}

void main()
{
    ivec2 px = ivec2(gl_GlobalInvocationID.xy);
	ivec2 extent = textureSize(sdfImage, 0);
	if (px.x > extent.x || px.y > extent.y)
		return;

	int angular = int(pow(2, pushConstants.cascadeIndex));
	ivec2 linearDist = extent / angular;
	
	ivec2 probeIndex = px % linearDist;
	ivec2 groupIndex = px / linearDist;

	int rayIndex = groupIndex.y * angular + groupIndex.x;
	int angular2 = angular * angular;

	ProbeInfo probe;
	probe.position = (probeIndex + 0.5) * angular;
	probe.offset = (pushConstants.cascadeInterval * (1 - angular2)) / (1 - 4);
	probe.range = pushConstants.cascadeInterval * angular2;

	int preavgIndex = rayIndex * 4;
    vec4 radiance = vec4(0);
	for (int i = 0; i < 4; i++)
	{
		int index = preavgIndex + i;
		probe.theta = float(index + 0.5) / float(angular2 * 4) * 6.28318530718;
		radiance += merge(raymarch(probe, extent), index, probe.position / vec2(extent)) * 0.25;
	}
	imageStore(currentCascade, px, radiance);
}