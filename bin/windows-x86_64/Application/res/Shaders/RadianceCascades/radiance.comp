#version 450

layout(set = 0, binding = 0) uniform GlobalFrameData{
    vec2 position;
    float radius;
    float clear;
    vec4 color;
} globalData;

layout(set = 0, binding = 1, rgba8) uniform image2D outputImage;

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

struct ProbeInfo
{
	vec2 position;
	float offset;
	float range;
	float theta;
};

vec4 raymarch(ProbeInfo probe)
{
    vec2 rayDir = vec2(cos(probe.theta), -sin(probe.theta));
    vec2 rayOrigin = probe.position + rayDir * probe.offset;

    vec2 circleCenter = globalData.position;
    float radius = globalData.radius;

    vec2 oc = rayOrigin - circleCenter;

    float b = dot(oc, rayDir);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = b * b - c;

    if (discriminant < 0.0) {
        return vec4(0.0);
    }

    float sqrtDisc = sqrt(discriminant);
    float t1 = -b - sqrtDisc;
    float t2 = -b + sqrtDisc;

    float t = -1.0;
    if (t1 >= 0.0 && t1 <= probe.range ||
		t2 >= 0.0 && t2 <= probe.range) 
	{
        return vec4(1, 0, 0, 1);
    }

    return vec4(0.0);
}

void main()
{
    ivec2 px = ivec2(gl_GlobalInvocationID.xy);

	if (globalData.clear > 0)
    {
        imageStore(outputImage, px, vec4(0, 0, 0, 1));
		return;
    }
    if (distance(px, ivec2(globalData.position)) < globalData.radius)
    {
        imageStore(outputImage, px, globalData.color);
		return;
    }

    float cascade0_linear = 16;
    float cascade_index = 0;
    float interval = 20;

    int probeSide = 2;
    int probeX = px.x % probeSide;
    int probeY = px.y % probeSide;
    float rayIndex = probeY * probeSide + probeX;
    float rayAngle = (rayIndex + 0.5) / (probeSide * probeSide) * 6.28318530718;
    float origin = (interval * (1 - pow(4, cascade_index))) / (1 - 4);
    float len = interval * pow(4, cascade_index);

	ProbeInfo probe;
	probe.position = px - vec2(probeX, probeY) + vec2(probeSide) * 0.5;
	probe.offset = origin;
	probe.range = len;
	probe.theta = rayAngle;
    vec4 radiance = raymarch(probe);
    imageStore(outputImage, px, radiance);

}

/*
struct probe_info { float angular; vec2 linear, size, probe; float index, offset, range, scale; };	// Information struct about scene probes within the cascade.
vec3 tosrgb(vec3 color) { return pow(color, vec3(2.2)); }

// Get the direction-first probe information associated with the each probe of the current cascade (in_CascadeIndex).
probe_info cascadeTexelInfo(vec2 coord) {
	float angular = pow(2.0, in_CascadeIndex);												// Ray Count.
	vec2 linear = vec2(in_CascadeLinear * pow(2.0, in_CascadeIndex));						// Cascade Probe Spacing.
	vec2 size = in_CascadeExtent / angular;                                                 // Size of Probe-Group.
	vec2 probe = mod(floor(coord), size);                                                   // Probe-Group Index.
	vec2 raypos = floor(in_TexelCoord * angular);                                           //	* spatial-xy ray-index position.
	float index = raypos.x + (angular * raypos.y);                                          // PreAvg Index (actual = index * 4).
	float offset = (in_CascadeInterval  * (1.0 - pow(4.0, in_CascadeIndex))) / (1.0 - 4.0);	// Offset of Ray Interval (geometric sum).
	float range = in_CascadeInterval * pow(4.0, in_CascadeIndex);							// Length of Ray Interval (geometric sum).
		range += length(vec2(in_CascadeLinear * pow(2.0, in_CascadeIndex+1.0)));			//	* light Leak Fix.
	float scale = length(in_RenderExtent);                                                  // Diagonal of Render Extent (for SDF scaling).
	return probe_info(angular * angular, linear, size, probe, index, offset, range, scale); // Output probe information struct.
}

// Cast a ray from a probe (point) in direction (theta) with an interval offset/range specified by probe_info (info).
vec4 raymarch(vec2 point, float theta, probe_info info) {
	vec2 texel = 1.0 / in_RenderExtent;																// Scalar for converting pixel-coordinates back to screen-space UV.
	vec2 delta = vec2(cos(theta), -sin(theta));														// Ray component to move in the direction of theta.
	vec2 ray = (point + (delta * info.offset)) * texel;												// Ray origin at interval offset starting point.
	
	for(float i = 0.0, df = 0.0, rd = 0.0; i < info.range; i++) {									// Loop for max length of interval (in event that ray SDF is near 0 for entire length of ray).
		df = V2F16(texture2D(in_DistanceField, ray).rg);											// Distance sample of scene converted from 2-byte encoded distance scene texture.
		rd += df * info.scale;																		// Sum up total ray distance traveled (scale from distance UV to pixel-coordinates).
		ray += (delta * df * info.scale * texel);													// Move ray along its direction by SDF distance sample.
		
		if (rd >= info.range || floor(ray) != vec2(0.0)) break;										// If ray has reached range or out-of-bounds, return no-hit.
		if (df <= EPS && rd <= EPS && in_CascadeIndex != 0.0) return vec4(0.0);						// 2D light only cast light at their surfaces, not their volume.
		//if (df < EPS) return vec4(texture2D(in_RenderScene, ray).rgb, 0.0);						// On-hit return radiance from scene (with visibility term of 0--e.g. no visibility to merge with higher cascades).
		if (df <= EPS) return vec4(tosrgb(texture2D(in_RenderScene, ray).rgb), 0.0);				// On-hit return radiance from scene (with visibility term of 0--e.g. no visibility to merge with higher cascades).
	}
	
	return vec4(0.0, 0.0, 0.0, 1.0);																// If no-hit return no radiance (with visibility term of 1--visibility to merge with higher cascades).
}

// Using hardware interpolation lookup 4 direction-first probes of cascade N+1 and merge with radiance of cascade N.
vec4 merge(vec4 rinfo, float index, probe_info pinfo) {
	if (rinfo.a == 0.0 || in_CascadeIndex >= in_CascadeCount - 1.0)							// For any radiance with zero-alpha do not merge (highest cascade also cannot merge).
		return vec4(rinfo.rgb, 1.0 - rinfo.a);												// Return non-merged radiance (invert alpha to correct alpha from raymarch ray-visibility term).
	
	float angularN1 = pow(2.0, in_CascadeIndex + 1.0);										// Angular resolution of cascade N+1 for probe lookups.
	vec2 sizeN1 = pinfo.size * 0.5;															// Size of probe group of cascade N+1 (N+1 has 1/4 total probe count or 1/2 each x,y axis).
	vec2 probeN1 = vec2(mod(index, angularN1), floor(index / angularN1)) * sizeN1;			// Get the probe group correlated to the ray index passed of the current cascade ray we're merging with.
	vec2 interpUVN1 = (pinfo.probe * 0.5) + 0.25;											// Interpolated probe position in cascade N+1 (layouts match but with 1/2 count, probe falls into its interpolated position by default).
	vec2 clampedUVN1 = max(vec2(1.0), min(interpUVN1, sizeN1 - 1.0));						// Clamp interpolated probe position away from edge to avoid hardware inteprolation affecting merge lookups from adjacet probe groups.
	vec2 probeUVN1 = probeN1 + clampedUVN1;													// Final lookup cascade position of the interpolated merge lookup.
	vec4 interpolated = texture2D(gm_BaseTexture, probeUVN1 * (1.0 / in_CascadeExtent));	// Texture lookup of the merge sample.
	return rinfo + interpolated;															// Return original radiance input and merge with lookup sample.
}

// Single-Pass Cast-Interval and Merge fragment shader (cast cascade[N] intervals and merge with intervals of cascade[N+1].
void main() {
	probe_info pinfo = cascadeTexelInfo(floor(in_TexelCoord * in_CascadeExtent));		// Get info about the current probe on screen (position, angular index, etc.).
	vec2 origin = (pinfo.probe + 0.5) * pinfo.linear;									// Get this probes position in screen space.
	float preavg_index = pinfo.index * 4.0;												// Convert this probe's pre-averaged index to its actual angular index (casting 4x rays, but storing 1x averaged).
	float theta_scalar = TAU / (pinfo.angular * 4.0);									// Get the scalar for converting our angular index to radians (0 to 2pi).
	
	for(float i = 0.0; i < 4.0; i++) {													// Cast 4 rays, one for each angular index for this pre-averaged ray.
		float index = preavg_index + float(i),											// Get the actual index for this pre-averaged ray.
			theta = (index + 0.5) * theta_scalar;										// Get the actual angle (theta) for this pre-averaged ray.
		
		vec4 rinfo = raymarch(origin, theta, pinfo);
		gl_FragColor += merge(rinfo, index, pinfo) * 0.25;
	}
	
	if (in_CascadeIndex == 0.0)															// Only for cascade0, apply sRGB conversion.
		gl_FragColor = vec4(pow(gl_FragColor.rgb, vec3(1.0 / 2.2)), 1.0);				// sRGB apporximation.
}

*/